{
  "version": 3,
  "sources": ["../src/orcid.ts"],
  "sourcesContent": ["'use strict'\n\n/**\n * Checks that a string is a valid ORCID of any format\n * @param {string} input String to test format of\n * @returns {boolean}\n */\nexport function inAcceptedFormat(input: string): boolean {\n  if (typeof input !== 'string') throw TypeError('Input must be string')\n  return /^((https?:\\/\\/)?orcid\\.org\\/)?([0-9]{4}-?){3}[0-9]{3}[0-9X]$/i.test(input)\n}\n\n/**\n * Converts a valid ORCID (of any format) into the dashed format\n * @param {string} input Any valid ORCID\n * @returns {string}\n */\nexport function toDashFormat(input: string): string {\n  const noDash = toNoDashFormat(input)\n  return [0, 4, 8, 12].map(it => noDash.slice(it, it + 4)).join('-')\n}\n\n/**\n * Converts a valid ORCID (of any format) into the non-dashed format (without validating the input first - useful internally)\n * @param {string} input Any valid ORCID\n * @returns {string}\n */\nexport function toNoDashFormatWithoutValidation(input: string): string {\n  return input.replace(/-/g, '').slice(-16).toUpperCase()\n}\n\n/**\n * Converts a valid ORCID (of any format) into the non-dashed format\n * @param {string} input Any valid ORCID\n * @returns {string}\n */\nexport function toNoDashFormat(input: string): string {\n  validate(input)\n  return toNoDashFormatWithoutValidation(input)\n}\n\n/**\n * Converts an ORCID to its corresponding URI, e.g. https://orcid.org/xxxxxxx......\n * @param {string} input Any valid ORCID\n * @param {boolean=} secure true (default): https, false: http\n * @returns {string}\n */\nexport function toUriWithProtocol(input: string, secure?: boolean): string {\n  return (secure === undefined || !!secure ? 'https' : 'http') + '://' + toUriWithoutProtocol(input)\n}\n\n/**\n * Converts an ORCID to is corresponding URI, without a protocol, e.g. orcid.org/xxxxxx.....\n * @param {string} input Any valid ORCID\n * @returns {string}\n */\nexport function toUriWithoutProtocol(input: string): string {\n  return 'orcid.org/' + toDashFormat(input)\n}\n\n/**\n * Returns true or false indicating whether a string conforms to any format of ORCID.\n * @param {string} input Any string to test\n * @returns {boolean}\n */\nexport function isValid(input: string): boolean {\n  if (!inAcceptedFormat(input)) return false\n  const inputNoDash = toNoDashFormatWithoutValidation(input)\n\n  let total = 0\n  for (let i = 0; i < 15; i++) {\n    total = (total + +inputNoDash[i]) * 2\n  }\n  const result = (12 - (total % 11)) % 11\n  return inputNoDash[15] === (result === 10 ? 'X' : result + '')\n}\n\n/**\n * A side-effect version of `isValid` - will throw Error if `isValid` would return false.\n * @param {string} input\n * @returns {void}\n */\nexport function validate(input: string): void {\n  if (!isValid(input)) throw Error('Invalid ORCID')\n}\n\nexport const ORCID = {\n  isValid,\n  validate,\n  inAcceptedFormat,\n  toDashFormat,\n  toNoDashFormat,\n  toUriWithProtocol,\n  toUriWithoutProtocol,\n}\n// if (typeof exports !== 'undefined') Object.assign(exports, ORCID)\n// if (typeof window !== 'undefined') Object.assign(window, { ORCID })\n"],
  "mappings": "2hBAAA,iNAOO,WAA0B,EAAwB,CACvD,GAAI,MAAO,IAAU,SAAU,KAAM,WAAU,wBAC/C,MAAO,gEAAgE,KAAK,GAQvE,WAAsB,EAAuB,CAClD,KAAM,GAAS,EAAe,GAC9B,MAAO,CAAC,EAAG,EAAG,EAAG,IAAI,IAAI,GAAM,EAAO,MAAM,EAAI,EAAK,IAAI,KAAK,KAQzD,WAAyC,EAAuB,CACrE,MAAO,GAAM,QAAQ,KAAM,IAAI,MAAM,KAAK,cAQrC,WAAwB,EAAuB,CACpD,SAAS,GACF,EAAgC,GASlC,WAA2B,EAAe,EAA0B,CACzE,MAAQ,KAAW,QAAa,CAAC,CAAC,EAAS,QAAU,QAAU,MAAQ,EAAqB,GAQvF,WAA8B,EAAuB,CAC1D,MAAO,aAAe,EAAa,GAQ9B,WAAiB,EAAwB,CAC9C,GAAI,CAAC,EAAiB,GAAQ,MAAO,GACrC,KAAM,GAAc,EAAgC,GAEpD,GAAI,GAAQ,EACZ,OAAS,GAAI,EAAG,EAAI,GAAI,IACtB,EAAS,GAAQ,EAAC,EAAY,IAAM,EAEtC,KAAM,GAAU,IAAM,EAAQ,IAAO,GACrC,MAAO,GAAY,MAAS,KAAW,GAAK,IAAM,EAAS,IAQtD,WAAkB,EAAqB,CAC5C,GAAI,CAAC,EAAQ,GAAQ,KAAM,OAAM,iBAG5B,KAAM,GAAQ,CACnB,UACA,WACA,mBACA,eACA,iBACA,oBACA",
  "names": []
}
