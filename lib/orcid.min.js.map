{
  "version": 3,
  "sources": ["../src/orcid.ts"],
  "sourcesContent": ["'use strict'\n\n/**\n * Checks that a string is a valid ORCID of any format\n * @param {string} input String to test format of\n * @returns {boolean}\n */\nfunction inAcceptedFormat(input: string): boolean {\n  if (typeof input !== 'string') throw TypeError('Input must be string')\n  return /^((https?:\\/\\/)?orcid\\.org\\/)?([0-9]{4}-?){3}[0-9]{3}[0-9X]$/i.test(input)\n}\n\n/**\n * Converts a valid ORCID (of any format) into the dashed format\n * @param {string} input Any valid ORCID\n * @returns {string}\n */\nfunction toDashFormat(input: string): string {\n  const noDash = toNoDashFormat(input)\n  return [0, 4, 8, 12].map(it => noDash.slice(it, it + 4)).join('-')\n}\n\n/**\n * Converts a valid ORCID (of any format) into the non-dashed format (without validating the input first - useful internally)\n * @param {string} input Any valid ORCID\n * @returns {string}\n */\nfunction toNoDashFormatWithoutValidation(input: string): string {\n  return input.replace(/-/g, '').slice(-16).toUpperCase()\n}\n\n/**\n * Converts a valid ORCID (of any format) into the non-dashed format\n * @param {string} input Any valid ORCID\n * @returns {string}\n */\nfunction toNoDashFormat(input: string): string {\n  validate(input)\n  return toNoDashFormatWithoutValidation(input)\n}\n\n/**\n * Converts an ORCID to its corresponding URI, e.g. https://orcid.org/xxxxxxx......\n * @param {string} input Any valid ORCID\n * @param {boolean=} secure true (default): https, false: http\n * @returns {string}\n */\nfunction toUriWithProtocol(input: string, secure?: boolean): string {\n  return (secure === undefined || !!secure ? 'https' : 'http') + '://' + toUriWithoutProtocol(input)\n}\n\n/**\n * Converts an ORCID to is corresponding URI, without a protocol, e.g. orcid.org/xxxxxx.....\n * @param {string} input Any valid ORCID\n * @returns {string}\n */\nfunction toUriWithoutProtocol(input: string): string {\n  return 'orcid.org/' + toDashFormat(input)\n}\n\n/**\n * Returns true or false indicating whether a string conforms to any format of ORCID.\n * @param {string} input Any string to test\n * @returns {boolean}\n */\nfunction isValid(input: string): boolean {\n  if (!inAcceptedFormat(input)) return false\n  const inputNoDash = toNoDashFormatWithoutValidation(input)\n\n  let total = 0\n  for (let i = 0; i < 15; i++) {\n    total = (total + +inputNoDash[i]) * 2\n  }\n  const result = (12 - (total % 11)) % 11\n  return inputNoDash[15] === (result === 10 ? 'X' : result + '')\n}\n\n/**\n * A side-effect version of `isValid` - will throw Error if `isValid` would return false.\n * @param {string} input\n * @returns {void}\n */\nfunction validate(input: string): void {\n  if (!isValid(input)) throw Error('Invalid ORCID')\n}\n\nconst ORCID = {\n  isValid,\n  validate,\n  inAcceptedFormat,\n  toDashFormat,\n  toNoDashFormat,\n  toUriWithProtocol,\n  toUriWithoutProtocol,\n}\nif (typeof exports !== 'undefined') Object.assign(exports, ORCID)\nif (typeof window !== 'undefined') Object.assign(window, { ORCID })\n"],
  "mappings": "aAOA,WAA0B,EAAwB,CAChD,GAAI,MAAO,IAAU,SAAU,KAAM,WAAU,wBAC/C,MAAO,gEAAgE,KAAK,GAQ9E,WAAsB,EAAuB,CAC3C,KAAM,GAAS,EAAe,GAC9B,MAAO,CAAC,EAAG,EAAG,EAAG,IAAI,IAAI,GAAM,EAAO,MAAM,EAAI,EAAK,IAAI,KAAK,KAQhE,WAAyC,EAAuB,CAC9D,MAAO,GAAM,QAAQ,KAAM,IAAI,MAAM,KAAK,cAQ5C,WAAwB,EAAuB,CAC7C,SAAS,GACF,EAAgC,GASzC,WAA2B,EAAe,EAA0B,CAClE,MAAQ,KAAW,QAAa,CAAC,CAAC,EAAS,QAAU,QAAU,MAAQ,EAAqB,GAQ9F,WAA8B,EAAuB,CACnD,MAAO,aAAe,EAAa,GAQrC,WAAiB,EAAwB,CACvC,GAAI,CAAC,EAAiB,GAAQ,MAAO,GACrC,KAAM,GAAc,EAAgC,GAEpD,GAAI,GAAQ,EACZ,OAAS,GAAI,EAAG,EAAI,GAAI,IACtB,EAAS,GAAQ,EAAC,EAAY,IAAM,EAEtC,KAAM,GAAU,IAAM,EAAQ,IAAO,GACrC,MAAO,GAAY,MAAS,KAAW,GAAK,IAAM,EAAS,IAQ7D,WAAkB,EAAqB,CACrC,GAAI,CAAC,EAAQ,GAAQ,KAAM,OAAM,iBAGnC,KAAM,GAAQ,CACZ,UACA,WACA,mBACA,eACA,iBACA,oBACA,wBAEF,AAAI,MAAO,UAAY,aAAa,OAAO,OAAO,QAAS,GACvD,MAAO,SAAW,aAAa,OAAO,OAAO,OAAQ,CAAE",
  "names": []
}
